#include <bits/stdc++.h>
#include <unistd.h>
#include <sys/wait.h>
#include <fcntl.h>
using namespace std;


vector<string> split_whitespace(const string &s){ vector<string> t; string cur; bool in_sq=false,in_dq=false; for(char c:s){ if(c=='\'' && !in_dq){ in_sq=!in_sq; if(!in_sq){ t.push_back(cur); cur.clear(); } continue; } if(c=='\"' && !in_sq){ in_dq=!in_dq; if(!in_dq){ t.push_back(cur); cur.clear(); } continue; } if(!in_sq && !in_dq && isspace((unsigned char)c)){ if(!cur.empty()){ t.push_back(cur); cur.clear(); } } else cur.push_back(c);} if(!cur.empty()) t.push_back(cur); return t; }


vector<vector<string>> parse_pipeline(const string &line, string &infile, string &outfile){
// very simple: split by '|', then process < and > in first/last
vector<string> parts;
string cur;
int depth=0; // ignore quotes roughly
for(size_t i=0;i<line.size();++i){ char c=line[i]; if(c=='\'' || c=='\"') { cur.push_back(c); continue; } if(c=='|' && depth==0){ parts.push_back(cur); cur.clear(); } else cur.push_back(c); }
if(!cur.empty()) parts.push_back(cur);
vector<vector<string>> cmds;
for(size_t i=0;i<parts.size();++i){ string p=parts[i]; auto toks = split_whitespace(p);
// check redirections only on first/last
if(i==0){ for(auto it=toks.begin(); it!=toks.end(); ){ if(*it=="<" && next(it)!=toks.end()){ infile = *next(it); it = toks.erase(it, next(it)+1); } else ++it; } }
if(i+1==parts.size()){ for(auto it=toks.begin(); it!=toks.end(); ){ if(*it==">" && next(it)!=toks.end()){ outfile = *next(it); it = toks.erase(it, next(it)+1); } else ++it; } }
if(!toks.empty()) cmds.push_back(toks);
}
return cmds;
}


int main(){
string line;
while(true){
cout<<"d4sh> "; if(!getline(cin,line)) break; if(line=="exit") break; if(line.empty()) continue;
string infile, outfile;
auto cmds = parse_pipeline(line, infile, outfile);
int n = cmds.size();
vector<int> pipes;
for(int i=0;i<n-1;++i){ int fds[2]; if(pipe(fds)<0){ perror("pipe"); break; } pipes.push_back(fds[0]); pipes.push_back(fds[1]); }
vector<pid_t> pids;
for(int i=0;i<n;++i){ pid_t pid = fork(); if(pid==0){
// stdin
if(i==0 && !infile.empty()){
int fd = open(infile.c_str(), O_RDONLY);
if(fd<0) { perror("open infile"); exit(1); }
dup2(fd, STDIN_FILENO); close(fd);
}
if(i>0){ int readfd = pipes[(i-1)*2]; dup2(readfd, STDIN_FILENO); }
// stdout
if(i==n-1 && !outfile.empty()){
int fd = open(outfile.c_str(), O_WRONLY | O_CREAT | O_TRUNC, 0644);
if(fd<0){ perror("open outfile"); exit(1); }
dup2(fd, STDOUT_FILENO); close(fd);
}
if(i<n-1){ int writefd = pipes[i*2+1]; dup2(writefd, STDOUT_FILENO); }
// close all pipes
for(int fd: pipes) close(fd);
// prepare argv
vector<char*> argv(cmds[i].size()+1);
for(size_t j=0;j<cmds[i].size();++j) argv[j]=strdup(cmds[i][j].c_str());
argv[cmds[i].size()] = nullptr;
execvp(argv[0], argv.data()); perror("exec"); exit(127);
} else if(pid>0) pids.push_back(pid);
else perror("fork");
}
// parent closes pipes
for(int fd: pipes) close(fd);
for(pid_t pid: pids) waitpid(pid, nullptr, 0);
}
return 0;
}
