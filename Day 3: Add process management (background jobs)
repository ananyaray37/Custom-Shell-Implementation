#include <bits/stdc++.h>
using namespace std;


struct Job { pid_t pid; string cmd; };
static vector<Job> jobs;


void sigchld_handler(int){
int saved = errno;
while(true){
int status; pid_t pid = waitpid(-1, &status, WNOHANG);
if(pid<=0) break;
// remove job
jobs.erase(remove_if(jobs.begin(), jobs.end(),[pid](const Job &j){ return j.pid==pid; }), jobs.end());
cout<<"\n[job done] pid="<<pid<<"\n";
cout<<"d3sh> "<<flush;
}
errno = saved;
}


vector<string> split_tokens(const string &line){
vector<string> tokens; string cur; bool in_sq=false, in_dq=false;
for(char c:line){
if(c=='\'' && !in_dq){ in_sq=!in_sq; if(!in_sq){ tokens.push_back(cur); cur.clear(); } continue; }
if(c=='\"' && !in_sq){ in_dq=!in_dq; if(!in_dq){ tokens.push_back(cur); cur.clear(); } continue; }
if(!in_sq && !in_dq && isspace((unsigned char)c)){
if(!cur.empty()){ tokens.push_back(cur); cur.clear(); }
} else cur.push_back(c);
}
if(!cur.empty()) tokens.push_back(cur);
return tokens;
}


int main(){
signal(SIGCHLD, sigchld_handler);
string line;
while(true){
cout<<"d3sh> ";
if(!getline(cin,line)) break;
auto tokens = split_tokens(line);
if(tokens.empty()) continue;
if(tokens[0]=="exit") break;
if(tokens[0]=="jobs"){
for(auto &j: jobs) cout<<"["<<j.pid<<"] "<<j.cmd<<"\n";
continue;
}
bool background = false;
if(tokens.back()=="&"){ background = true; tokens.pop_back(); }
vector<char*> argv(tokens.size()+1);
for(size_t i=0;i<tokens.size();++i) argv[i] = strdup(tokens[i].c_str());
argv[tokens.size()]=nullptr;
pid_t pid = fork();
if(pid==0){
if(background) setsid();
execvp(argv[0], argv.data());
perror("exec"); exit(127);
} else if(pid>0){
if(background){
jobs.push_back({pid, line});
cout<<"[started] pid="<<pid<<"\n";
} else {
int status; waitpid(pid, &status, 0);
}
} else perror("fork");
for(char* p: argv) if(p) free(p);
}
return 0;
}
